<!doctype html><html lang="en"><head><script type="text/javascript">console.log("Fired")</script><meta charset="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="viewport" content="width=device-width,initial-scale=1"/><link rel="apple-touch-icon" href="/logo.png"/><link rel="manifest" href="/manifest.json"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"/><link rel="stylesheet" id="font-css" href="https://fonts.googleapis.com/css2?display=swap&amp;family=Nunito%3Awght%40400%3B600%3B700" media="" as="style" onload='this.onload=null,this.rel="stylesheet"'/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"/><meta http-equiv="content-type" content="text/html; charset=UTF-8;charset=utf-8"/><link rel="fluid-icon" href="/logo.png" title="WhizSid"/><meta name="page-subject" content="WhizSid"/><meta name="theme-color" content="#151853"/><meta name="HandheldFriendly" content="true"/><title>WhizSid - Portfolio And Blog Posts</title><style>code,pre{white-space:pre-wrap!important}body{margin:0;padding:0;font-family:nunito,sans-serif}a:active,a:link,a:visited{color:inherit!important;text-decoration:none!important}.load{position:relative;margin:auto;width:100px;height:80px;margin-top:45vw;margin-top:calc(50vh - 100px)}.gear{position:absolute;z-index:-10;width:40px;height:40px;animation:spin 5s infinite}.two{left:40px;width:80px;height:80px;animation:spin-reverse 5s infinite}.three{top:45px;left:-10px;width:60px;height:60px}@keyframes spin{50%{transform:rotate(360deg)}}@keyframes spin-reverse{50%{transform:rotate(-360deg)}}.lil-circle{position:absolute;border-radius:50%;box-shadow:inset 0 0 10px 2px gray,0 0 50px #fff;width:100px;height:100px;opacity:.65}.blur-circle{position:absolute;top:-19px;left:-19px}.text{color:#d3d3d3;font-size:18px;font-family:nunito,sans-serif;text-align:center;margin-top:60px}.loading-fixed{height:100vh;background:#fff;position:fixed;top:0;left:0;display:block;z-index:9999;width:100vw}</style><script>window.onload=function(){document.getElementsByClassName("loading-fixed")[0].remove()}</script><link href="/static/css/2.8f263818.chunk.css" rel="stylesheet"><meta property="og:title" content="WhizSid| Displaying a list of paths as a Material UI tree view"/><meta name="description" property="og:description" content="Most of react developers using the Material UI as their day-to-day framework. But they are facing lot of issues when using dynamic nested lists. But when developing a file browser we have to use dynamic nested lists, state managements and data processing together. So it will get more complicated if we start it with a wrong step. This post contains an A-Z guide for creating a file browser." /><meta property="keywords" content="Post, Typescript, material-ui, react, ui-ux, blog, beginner, advanced, step by step" /><meta property="og:type" content="article"/><meta property="og:article:published_time" content="2021-04-16T21:04:14Z"/><meta property="og:article:modified_time" content="2021-11-23T09:41:26Z"/><meta name="author" content="Ramesh Kithsiri"/><meta property="og:article:author:first_name" content="Ramesh"/><meta property="og:article:author:last_name" content="Kithsiri"/><meta property="og:article:author:username" content="whizsid"/><meta property="fb:app_id" content="129537969147552"/><meta property="og:article:section" content="Software Engineering"/><meta property="og:article:tag" content="Post"/><meta property="og:article:tag" content="Typescript"/><meta property="og:article:tag" content="material-ui"/><meta property="og:article:tag" content="react"/><meta property="og:article:tag" content="ui-ux"/><meta property="og:image" content="https://github.com/whizsid/whizsid.github.io/raw/src/blog/images/material_ui_paths_tree_view.png"/><meta property="og:url" content="https://whizsid.github.io/blog/10/displaying-a-list-of-paths-as-a-material-ui-tree-view.html"/><body style="margin:0;background:#e8eaed"><div style="display:none" class="loading-fixed"><div class="load"><div class="gear one"><svg id="blue" viewbox="0 0 100 100" fill="#94DDFF"><path d="M97.6,55.7V44.3l-13.6-2.9c-0.8-3.3-2.1-6.4-3.9-9.3l7.6-11.7l-8-8L67.9,20c-2.9-1.7-6-3.1-9.3-3.9L55.7,2.4H44.3l-2.9,13.6      c-3.3,0.8-6.4,2.1-9.3,3.9l-11.7-7.6l-8,8L20,32.1c-1.7,2.9-3.1,6-3.9,9.3L2.4,44.3v11.4l13.6,2.9c0.8,3.3,2.1,6.4,3.9,9.3      l-7.6,11.7l8,8L32.1,80c2.9,1.7,6,3.1,9.3,3.9l2.9,13.6h11.4l2.9-13.6c3.3-0.8,6.4-2.1,9.3-3.9l11.7,7.6l8-8L80,67.9      c1.7-2.9,3.1-6,3.9-9.3L97.6,55.7z M50,65.6c-8.7,0-15.6-7-15.6-15.6s7-15.6,15.6-15.6s15.6,7,15.6,15.6S58.7,65.6,50,65.6z"></path></svg></div><div class="gear two"><svg id="pink" viewbox="0 0 100 100" fill="#FB8BB9"><path d="M97.6,55.7V44.3l-13.6-2.9c-0.8-3.3-2.1-6.4-3.9-9.3l7.6-11.7l-8-8L67.9,20c-2.9-1.7-6-3.1-9.3-3.9L55.7,2.4H44.3l-2.9,13.6      c-3.3,0.8-6.4,2.1-9.3,3.9l-11.7-7.6l-8,8L20,32.1c-1.7,2.9-3.1,6-3.9,9.3L2.4,44.3v11.4l13.6,2.9c0.8,3.3,2.1,6.4,3.9,9.3      l-7.6,11.7l8,8L32.1,80c2.9,1.7,6,3.1,9.3,3.9l2.9,13.6h11.4l2.9-13.6c3.3-0.8,6.4-2.1,9.3-3.9l11.7,7.6l8-8L80,67.9      c1.7-2.9,3.1-6,3.9-9.3L97.6,55.7z M50,65.6c-8.7,0-15.6-7-15.6-15.6s7-15.6,15.6-15.6s15.6,7,15.6,15.6S58.7,65.6,50,65.6z"></path></svg></div><div class="gear three"><svg id="yellow" viewbox="0 0 100 100" fill="#FFCD5C"><path d="M97.6,55.7V44.3l-13.6-2.9c-0.8-3.3-2.1-6.4-3.9-9.3l7.6-11.7l-8-8L67.9,20c-2.9-1.7-6-3.1-9.3-3.9L55.7,2.4H44.3l-2.9,13.6      c-3.3,0.8-6.4,2.1-9.3,3.9l-11.7-7.6l-8,8L20,32.1c-1.7,2.9-3.1,6-3.9,9.3L2.4,44.3v11.4l13.6,2.9c0.8,3.3,2.1,6.4,3.9,9.3      l-7.6,11.7l8,8L32.1,80c2.9,1.7,6,3.1,9.3,3.9l2.9,13.6h11.4l2.9-13.6c3.3-0.8,6.4-2.1,9.3-3.9l11.7,7.6l8-8L80,67.9      c1.7-2.9,3.1-6,3.9-9.3L97.6,55.7z M50,65.6c-8.7,0-15.6-7-15.6-15.6s7-15.6,15.6-15.6s15.6,7,15.6,15.6S58.7,65.6,50,65.6z"></path></svg></div><div class="lil-circle"></div><svg class="blur-circle"><filter id="blur"><fegaussianblur in="SourceGraphic" stddeviation="13"></fegaussianblur></filter><circle cx="70" cy="70" r="66" fill="transparent" stroke="white" stroke-width="40" filter="url(#blur)"></circle></svg></div><div class="text">loading</div></div><script type="text/javascript">document.querySelector(".loading-fixed").setAttribute("style","display: block")</script><noscript>You need to enable JavaScript to run this app.</noscript><div id="root"><h1 id="displaylistofpathsasamaterialuitreeview">Display list of paths as a material UI tree view</h1>
<p>Material UI is a popular frontend react framework. And it has very
useful and easy to use components. But when you developing a
react tree viewer for browsing files, it will mess you up. Because
Material UI has a different approach to make nested lists.</p>
<ul>
<li>How to create nested lists on other frameworks.</li>
</ul>
<pre><code class="tsx language-tsx">&lt;List&gt;
    &lt;ListItem&gt;
        &lt;ListItemText primary="Item 1"/&gt;
        &lt;List&gt;
            &lt;ListItem&gt;
                &lt;ListItemText primary="Nested Item 1"/&gt;
            &lt;/ListItem&gt;
        &lt;/List&gt;
    &lt;/ListItem&gt;
&lt;/List&gt;
</code></pre>
<ul>
<li>How to create nested lists on Material UI.</li>
</ul>
<pre><code class="tsx language-tsx">&lt;List&gt;
    &lt;ListItem&gt;
        &lt;ListItemText primary="Item 1"/&gt;
    &lt;/ListItem&gt;
    &lt;Collapse in={open} &gt;
        &lt;List&gt;
            &lt;ListItem&gt;
                &lt;ListItemText primary="Nested Item 1"/&gt;
            &lt;/ListItem&gt;
        &lt;/List&gt;
    &lt;/Collapse&gt;
&lt;/List&gt;
</code></pre>
<p>So rendering process will getting complicated if you processed your
list of paths first. </p>
<h2 id="initializingtheproject">Initializing the project</h2>
<p>As a quick start download the <a href="https://github.com/mui-org/material-ui/tree/master/examples/create-react-app-with-typescript">Material UI React
Example</a> to your local folder.</p>
<pre><code>$ curl https://codeload.github.com/mui-org/material-ui/tar.gz/master | tar -xz --strip=3 material-ui-master/examples/create-react-app-with-typescript
</code></pre>
<p>And also install all dependencies.</p>
<pre><code>$ yarn
</code></pre>
<p>And delete all other components and make it as an empty project.</p>
<pre><code class="tsx language-tsx"># src/App.tsx

import Box from "@material-ui/core/Box";
import Container from "@material-ui/core/Container";
import Typography from "@material-ui/core/Typography";
import React from "react";

export default function App() {
  return (
    &lt;Container maxWidth="sm"&gt;
      &lt;Box my={4}&gt;
        &lt;Typography variant="h4" component="h1" gutterBottom&gt;
            File Browser
        &lt;/Typography&gt;
      &lt;/Box&gt;
    &lt;/Container&gt;
  );
}
</code></pre>
<h2 id="creatingacomponent">Creating a component</h2>
<p>Next create an empty component to implement our file browser.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

import withStyles from "@material-ui/core/styles/withStyles";
import * as React from "react";

const styler = withStyles((theme) =&gt; ({
    root: {
        width: 400,
    },
}));

interface FileBrowserProps {
    classes: {
        root: string;
    };
}

class FileBrowser extends React.Component&lt;FileBrowserProps&gt; {
    public render() {
        const { classes } = this.props;
        return &lt;div className={classes.root}&gt;My File Browser&lt;/div&gt;;
    }
}

export default styler(FileBrowser);
</code></pre>
<p>Also include it to 
the <code>App.tsx</code> to display on the browser.</p>
<pre><code class="tsx language-tsx"># src/App.tsx

// top of the file
import FileBrowser from "./FileBrowser";

// Inside render function
&lt;FileBrowser/&gt;
</code></pre>
<p>At the moment this component contains only a text.</p>
<h2 id="takingpathstothecomponent">Taking paths to the component</h2>
<p>To take the paths as a prop to our <code>FileBrowser</code> component, add it to
the prop types.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

interface FileBrowserProps {
    // ...
    paths: string[];
}
</code></pre>
<p>And also pass paths as a prop from the <code>App</code> component.</p>
<pre><code class="tsx language-tsx"># src/App.tsx

&lt;FileBrowser
    paths={[
        "abc/def",
        "abc/ghi/jkl",
        "abc/ghi/yz/",
        "pqr",
        "abc/ghi/mno",
        "stu/vwx",
    ]}
/&gt;
</code></pre>
<h2 id="renderingthetreeview">Rendering the tree view</h2>
<p>When rendering tree views, we have to use nested functions. Because
rendering process must do in a dynamic way.</p>
<p>Define a function named <code>renderList</code> in the <code>FileBrowser</code> component to
render file lists. This function should take all paths as an array of
strings. And it should return an array of <code>ListItem | Collapse</code>
elements. So I am using the return type as a generic <code>JSX.Element</code>.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

import List from "@material-ui/core/List";
// ...

class FileBrowser extends React.Component&lt;FileBrowserProps&gt; {

    protected renderList(paths: string[]): JSX.Element[]{

    }

    public render() {
        const { classes, paths } = this.props;
        return &lt;div className={classes.root}&gt;
                &lt;List&gt;
                    {this.renderList(paths)}
                &lt;/List&gt;
            &lt;/div&gt;;
    }
}
</code></pre>
<p>Now typescript compiler will returning an error that saying "A function
whose declared type is neither 'void' nor 'any' must return a value.".
It means we should return an array of elements. So define an
empty array and return it to temporarily resolve this error.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

protected renderList(paths: string[]): JSX.Element[]{
    const listItems: JSX.Element[] = [];

    return listItems;
}
</code></pre>
<p>As the next step we should render the root elements by iterating over
paths once.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

import ListItem from "@material-ui/core/ListItem";
import ListItemText from "@material-ui/core/ListItemText";

// ...
const listItems: JSX.Element[] = [];

paths.forEach((path) =&gt; {
    const slices = path.split("/");

    listItems.push(
        &lt;ListItem&gt;
            &lt;ListItemText primary={slices[0]} /&gt;
        &lt;/ListItem&gt;
    );
});

return listItems;
// ...
</code></pre>
<p>Now you can see a list of folder names on the browser. But it has
duplicated folder names. To avoid these duplicates, we should push those
elements to the array once all child nodes iterated. So we need to 
define another variable to store the previous folder name. After that we
can compare it with the current folder name and push items to the array
if current folder name and previous folder names are different.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

protected renderList(paths: string[]): JSX.Element[] {
    const listItems: JSX.Element[] = [];
    let previous: string | undefined;

    paths.forEach((path) =&gt; {
        const slices = path.split("/");
        const current = slices[0];

        if (previous &amp;&amp; previous !== current) {
            listItems.push(
                &lt;ListItem&gt;
                    &lt;ListItemText primary={previous} /&gt;
                &lt;/ListItem&gt;
            );
        }
        previous = current;
    });

    listItems.push(
        &lt;ListItem&gt;
            &lt;ListItemText primary={previous} /&gt;
        &lt;/ListItem&gt;
    );

    return listItems;
}
</code></pre>
<p>Now the first duplicated item rendered as a one item. But there is
one more duplicated item after the second item. This duplicated item was
happened because we did not used any sorting algorithm. We have to sort
all paths by the nested level and the name.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

// ...
const sortedPaths = paths.sort((a, b) =&gt; {
    return (
        b.split("/").length - a.split("/").length || a.localeCompare(b)
    );
});

sortedPaths.forEach((path) =&gt; {
// ...
</code></pre>
<p>All items of the root list has rendered without any issue. Now we have
to render sub lists. Before that there is a small nit
to fix. We can define a new function to render items and later we can 
reuse it in both places.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

import Collapse from "@material-ui/core/Collapse";
// ...

/**
 * @param pwd The current path location
 * @param path The path to render
 * @param isDir Weather that item is a directory or not
 * @param childrens If this item is a directory, it's childs.
 */
protected renderItem(
    pwd: string,
    path: string,
    isDir: boolean,
    childrens: string[] = []
): JSX.Element {
    const name = path.substr(pwd.length);
    return (
        &lt;React.Fragment&gt;
            &lt;ListItem&gt;
                &lt;ListItemText primary={name} /&gt;
            &lt;/ListItem&gt;
            {isDir &amp;&amp; (
                &lt;Collapse in={true}&gt;
                    &lt;List&gt;{this.renderList(childrens)}&lt;/List&gt;
                &lt;/Collapse&gt;
            )}
        &lt;/React.Fragment&gt;
    );
}
</code></pre>
<p>When we rendering nested lists, we want to know the current nested level
and path. So we have to pass an additional parameter to the <code>renderList</code>
function to pass the current path. In the root folder it should be
empty.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

protected renderItem(
    pwd: string,
    path: string,
    isDir: boolean,
    childrens: string[] = []
): JSX.Element {
    // ...
    &lt;List&gt;{this.renderList(childrens, pwd.concat(name))}&lt;/List&gt;
    // ...
}

protected renderList(paths: string[], pwd: string = ""): JSX.Element[] {
// ...
}
</code></pre>
<p>By default <code>pwd</code> is an empty string. So in the root directory it
considering as an empty value. When rendering a sub directory we have to
pass the next path as <code>pwd</code>.</p>
<p>At the moment <code>renderList</code> function is not depending on the <code>pwd</code>. So it
will always provide names of the root folder, even in sub directories.
So we have to use <code>pwd</code> to stay away from this issue.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

// ...
sortedPaths.forEach((path) =&gt; {
    const relativePath = pwd? path.substr(pwd.length): path;
    const slices = relativePath.split("/");
    const current = slices[0];
    // ...
});
// ...
</code></pre>
<p>Next we have to store all child nodes in an array and render it with the
folder. After rendered the folder, the array should be empty to reuse it
for the next folder.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

protected renderList(paths: string[], pwd: string = ""): JSX.Element[] {
    // ...
    const nestedPaths: string[] = [];

    // ...
        if (previous &amp;&amp; previous !== current) {
            // ... 
            nestedPaths.length = 0;
        }
        nestedPaths.push(path);
</code></pre>
<p>After that we can use the <code>renderItem</code> function and pass all parameters
to it.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

protected renderList(paths: string[], pwd: string = ""): JSX.Element[] {
    // ...
    sortedPaths.forEach((path) =&gt; {
        // ...

        if (previous &amp;&amp; previous !== current) {
            listItems.push(
                this.renderItem(
                    pwd,
                    pwd.concat(previous, "/"),
                    false,
                    nestedPaths
                )
            );
            nestedPaths.length = 0;
        }
        nestedPaths.push(path);
        previous = current;
    });

    listItems.push(
        this.renderItem(
            pwd,
            pwd.concat(previous as string, "/"),
            false,
            nestedPaths
        )
    );

    return listItems;
}
</code></pre>
<p>But you can see all sublists were hidden. Because we always passed <code>false</code>
for the <code>isDir</code> parameter.</p>
<p>Always a directory contains a trailing back slash (<code>/</code>). So the value of 
<code>relativePath.split('/')</code> always should be more than one if it a directory.</p>
<p>We can use this logic to determine the weather if the item is a
directory or not.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

protected renderList(paths: string[], pwd: string = ""): JSX.Element[] {
    // ...
    const nestedPaths: string[] = [];
    let isPrevDir = false;

    // ...
    sortedPaths.forEach((path) =&gt; {
        // ...
        if (previous &amp;&amp; previous !== current) {
            listItems.push(
                this.renderItem(
                    pwd,
                    pwd.concat(previous, "/"),
                    isPrevDir,
                    nestedPaths
                )
            );
            // ...
        }
        // ...
        isPrevDir = slices.length&gt;1;
    });

    listItems.push(
        this.renderItem(
            pwd,
            pwd.concat(previous as string, "/"),
            isPrevDir,
            nestedPaths
        )
    );
    // ...
}
</code></pre>
<p>Now all lists were rendered. But in a same line. So we have to add a 
margin for sub lists to separate them from root list.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

const styler = withStyles((theme) =&gt; ({
    // ...
    list: {
        marginLeft: theme.spacing(4)
    },
}));

interface FileBrowserProps {
    classes: {
        // ...
        list: string;
    };
    // ...
}

// ...
    protected renderItem(
        pwd: string,
        path: string,
        isDir: boolean,
        childrens: string[] = []
    ): JSX.Element {
        const {classes} = this.props;
        // ...
            &lt;List className={classes.list}&gt;
        // ...
    }
</code></pre>
<p>You can see there are trailing backslashes in file names. We should
avoid these backslashes when concatenating.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

protected renderList(paths: string[], pwd: string = ""): JSX.Element[] {
    // ...
    if (previous &amp;&amp; previous !== current) {
        listItems.push(
            this.renderItem(
                pwd,
                pwd.concat(previous, isPrevDir ? "/" : ""),
                isPrevDir,
                nestedPaths
            )
        );
        nestedPaths.length = 0;
    } 
    // ...
    listItems.push(
        this.renderItem(
            pwd,
            pwd.concat(previous as string, isPrevDir ? "/" : ""),
            isPrevDir,
            nestedPaths
        )
    );
}
</code></pre>
<p>You can see an empty item after the <code>yz</code> folder. It caused because <code>yz</code>
is an empty folder. When we splitting empty directories by 
backslashes, An extra empty string will remain as the last item. We
should skip these empty folder names to resolve this issue.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

// ...
sortedPaths.forEach((path) =&gt; {
    const relativePath = path.substr(pwd.length);
    const slices = relativePath.split("/");
    const current = slices[0];

    if(current!=""){
        // ...
    }
}
// ...
if (previous) {
    listItems.push(
        this.renderItem(
            pwd,
            pwd.concat(previous, isPrevDir ? "/" : ""),
            isPrevDir,
            nestedPaths
        )
    );
}
</code></pre>
<p>Next add icons to identify folders and files separately. To add icons
install the <code>@material-ui/icons</code> package.</p>
<pre><code>$ yarn add @material-ui/icons@latest
</code></pre>
<p>And add it to <code>FileBrowser</code> component.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

// ...
import ListItemIcon from "@material-ui/core/ListItemIcon";
import Description from "@material-ui/icons/Description";
import Folder from "@material-ui/icons/Folder";

// ...
&lt;ListItem&gt;
    &lt;ListItemIcon&gt;
        {isDir ? &lt;Folder /&gt; : &lt;Description /&gt;}
    &lt;/ListItemIcon&gt;
    &lt;ListItemText primary={name} /&gt;
&lt;/ListItem&gt;
// ...
</code></pre>
<h2 id="foldingandunfolding">Folding and unfolding</h2>
<p>To manage folding and unfolding we have to implement some state
controllers. We can add all unfolded items in one array and check it
when rendering.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

// ...
interface FileBrowserState {
    unfolded: string[];
}

class FileBrowser extends React.Component&lt;FileBrowserProps, FileBrowserState&gt; {
    constructor(props: FileBrowserProps) {
        super(props);

        this.state = {
            unfolded: [],
        };
    }
}
</code></pre>
<p>As in the <a href="https://material-ui.com/components/lists/#nested-list">Material UI Documentation</a>
Check the folding state when rendering.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

protected renderItem(
    pwd: string,
    path: string,
    isDir: boolean,
    childrens: string[] = []
): JSX.Element {
    const { classes } = this.props;
    const { unfolded } = this.state;

    const name = path.substr(pwd.length);
    const unfold = unfolded.includes(path);

    return (
        &lt;React.Fragment&gt;
            &lt;ListItem&gt;
                &lt;ListItemIcon&gt;
                    {isDir ? &lt;Folder /&gt; : &lt;Description /&gt;}
                &lt;/ListItemIcon&gt;
                &lt;ListItemText primary={name} /&gt;
                    {isDir&amp;&amp;(unfold? &lt;ExpandLess /&gt; : &lt;ExpandMore/&gt;)}
            &lt;/ListItem&gt;
            {isDir &amp;&amp; (
                &lt;Collapse in={unfold}&gt;
                    &lt;List className={classes.list}&gt;
                        {this.renderList(childrens, pwd.concat(name))}
                    &lt;/List&gt;
                &lt;/Collapse&gt;
            )}
        &lt;/React.Fragment&gt;
    );
}
</code></pre>
<p>All sub lists are displaying as folded. Now we have to add an event to
manually fold and unfold them by my mouse clicks. </p>
<p>define a function to handle the fold and unfold events. This
function should remove a certain path from the array when folding. And
insert the path when unfolding. </p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

protected handleToggleList(path: string, fold: boolean){
    const {unfolded} = this.state;

    if(fold){
        this.setState({
            unfolded: unfolded.filter(p=&gt;!p.startsWith(path))
        });
    } else {
        this.setState({
            unfolded: [...unfolded, path]
        });
    }
}

protected renderItem(
    pwd: string,
    path: string,
    isDir: boolean,
    childrens: string[] = []
): JSX.Element {
    // ...
    &lt;ListItem
        button
        divider
        dense={true}
        onClick={() =&gt;
            isDir ? this.handleToggleList(path, unfold) : undefined
        }
    &gt;
    // ...
}
</code></pre>
<h2 id="sendingfileclickevents">Sending file click events</h2>
<p>The only way to send click events is taking a callback as a prop and
call the callback prop. define a callback prop in the <code>FileBrowser</code>
component and make it optional.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

interface FileBrowserProps {
    // ...
    onPreview?: (path: string)=&gt; void;
}
</code></pre>
<p>And call this event when after clicked on a file. change  <code>renderItem</code>
function as in below snippet.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

protected renderItem(
    pwd: string,
    path: string,
    isDir: boolean,
    childrens: string[] = []
): JSX.Element {
    const { classes, onPreview } = this.props;

    // ...
        &lt;ListItem
            button
            divider
            dense={true}
            onClick={() =&gt;
                isDir
                    ? this.handleToggleList(path, unfold)
                    : onPreview &amp;&amp; onPreview(path)
            }
        &gt;
    // ...
}
</code></pre>
<p>And pass a sample callback for <code>onPreview</code> prop from the <code>App</code> component.
So we can test the callback.</p>
<pre><code class="tsx language-tsx"># src/App.tsx

function onPreview(path: string) {
    console.log(`File:- ${path}`);
}

// ...
&lt;FileBrowser
    onPreview={onPreview}
    paths={[
        "abc/def",
        "abc/ghi/jkl",
        "abc/ghi/yz/",
        "pqr",
        "abc/ghi/mno",
        "stu/vwx",
    ]}
/&gt;
// ...
</code></pre>
<p>Every time you click on the items, console will notify you. Also you
can see an error <code>Each child in a list should have a unique "key"
prop.</code>. Add a unique key to all items to fix this issue. I am adding the
path as a key. Because path is unique for all items.</p>
<pre><code class="tsx language-tsx"># src/FileBrowser.tsx

// ...
&lt;React.Fragment key={path} &gt;
// ...
</code></pre>
<p>Now we successfully completed our <code>FileBrowser</code> component. You can
download the final <code>FileBrowser</code> component from the file section and
customize it as you want.</p></div><script>!function(e){function r(r){for(var n,l,f=r[0],i=r[1],p=r[2],c=0,s=[];c<f.length;c++)l=f[c],Object.prototype.hasOwnProperty.call(o,l)&&o[l]&&s.push(o[l][0]),o[l]=0;for(n in i)Object.prototype.hasOwnProperty.call(i,n)&&(e[n]=i[n]);for(a&&a(r);s.length;)s.shift()();return u.push.apply(u,p||[]),t()}function t(){for(var e,r=0;r<u.length;r++){for(var t=u[r],n=!0,f=1;f<t.length;f++){var i=t[f];0!==o[i]&&(n=!1)}n&&(u.splice(r--,1),e=l(l.s=t[0]))}return e}var n={},o={1:0},u=[];function l(r){if(n[r])return n[r].exports;var t=n[r]={i:r,l:!1,exports:{}};return e[r].call(t.exports,t,t.exports,l),t.l=!0,t.exports}l.m=e,l.c=n,l.d=function(e,r,t){l.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:t})},l.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},l.t=function(e,r){if(1&r&&(e=l(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(l.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var n in e)l.d(t,n,function(r){return e[r]}.bind(null,n));return t},l.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return l.d(r,"a",r),r},l.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},l.p="/";var f=this.webpackJsonpportfolio=this.webpackJsonpportfolio||[],i=f.push.bind(f);f.push=r,f=f.slice();for(var p=0;p<f.length;p++)r(f[p]);var a=i;t()}([])</script><script src="/static/js/2.7d21f870.chunk.js"></script><script src="/static/js/main.2d3dde33.chunk.js"></script></body></html>